import numpy
import scipy
import scipy.io
import pickle
import mbff.utilities.functions as util
from mbff.dataset.Exceptions import DatasetMatrixNotFinalizedError, DatasetMatrixFinalizedError

class DatasetMatrix:
    """
    This class maintains a pair of matrices ``X`` and ``Y``, along with their
    row labels and column labels. Its purpose is to pair together the two
    matrices of a real-world dataset, namely the feature variables (``X``) and
    objective variables (``Y``). Normally, a :py:class:`DatasetMatrix` instance is
    generated by a dataset source when reading an external dataset.

    The rows of ``X`` and ``Y`` at the same index represent a single sample in
    the dataset.  This means that the matrices ``X`` and ``Y`` have the same
    number of rows.

    :var label: The label used to identify this instance of :py:class:`DatasetMatrix`.
        It will be used when saving / loading the instance too.
    :var X: A ``scipy.sparse`` matrix where the rows represent samples and the
        columns represent the feature variables. Can be either a
        ``scipy.sparse.csr_matrix`` instance or a ``scipy.sparse.csc_matrix``
        instance.
    :var Y: A ``scipy.sparse`` matrix where the rows represent samples and the
        columns represent the objective variables. Can be either a
        ``scipy.sparse.csr_matrix`` instance or a ``scipy.sparse.csc_matrix``
        instance.
    :var row_labels: A list of strings where each element is the label of a
        corresponding sample in ``X`` and ``Y``. Has exactly as many elements
        as ``X`` and ``Y`` have rows.
    :var column_labels_X: A list of strings where each element is the label of
        a corresponding feature variable in ``X``. Has exactly as many elements
        as ``X`` has columns.
    :var column_labels_Y: A list of strings where each element is the label of
        a corresponding objective variable in ``Y``. Has exactly as many elements
        as ``Y`` has columns.
    :var final: A boolean flag which determines whether this :py:class:`DatasetMatrix`
        instance is final or not. Initially ``False``. Calling ``.finalize()``
        will set this to ``True``. Saving is possible only after finalizing. A
        loaded :py:class:`DatasetMatrix` is always finalized.
    """

    def __init__(self, label):
        self.label = label
        self.X = None
        self.Y = None
        self.row_labels = []
        self.column_labels_X = []
        self.column_labels_Y = []
        self.final = False


    def get_matrix(self, matrix_label):
        """
        Return the ``X`` or ``Y`` matrix, based on the value of
        ``matrix_label``.

        :param str matrix_label: The matrix to get, either ``"X"`` or ``"Y"``.
        :return: Either matrix in this DatasetMatrix: ``X`` or ``Y``.
        :rtype: ``scipy.sparse.csc_matrix`` or ``scipy.sparse.csr_matrix``,
            depending on whether :py:meth:`finalize` has been called or not.
        :raises ValueError: if ``matrix_label`` is neither ``"X"`` nor ``"Y""``.
        """
        if matrix_label == 'X':
            return self.X
        elif matrix_label == 'Y':
            return self.Y
        else:
            raise ValueError('Unknown matrix label. Only X and Y are allowed.')


    def get_column(self, matrix_label, column):
        """
        Retrieve the entire column specified by the argument ``column`` from
        either matrix ``X`` or ``Y``, depending on the value provided for
        ``matrix_label``.

         See also :py:meth:`get_column_X` and :py:meth:`get_column_Y`.

        :param str matrix_label: The matrix to get the column from, either
            ``"X"`` or ``"Y"``.
        :param int column: 0-based integer index of the column to retrieve.
        :return: A 1-dimensional Numpy array, as returned by
            :py:meth:`get_column_X` and :py:meth:`get_column_Y`
        :rtype: ``numpy.array`` of size ``(1, row_count)``.
        :raises ValueError: if ``matrix_label`` is neither ``"X"`` nor ``"Y""``.
        """
        if matrix_label == 'X':
            return self.get_column_X(column)
        elif matrix_label == 'Y':
            return self.get_column_Y(column)
        else:
            raise ValueError('Unknown matrix label. Only X and Y are allowed.')


    def get_column_labels(self, matrix_label):
        """
        Return the column labels of the matrix specified by ``matrix_label``.

        :param str matrix_label: The matrix to get the column labels for,
            either ``"X"`` or ``"Y"``.
        :return: Either ``self.column_labels_X`` or ``self.column_labels_Y``.
        :rtype: ``list(str)``
        :raises ValueError: if ``matrix_label`` is neither ``"X"`` nor ``"Y""``.
        """
        if matrix_label == 'X':
            return self.column_labels_X
        elif matrix_label == 'Y':
            return self.column_labels_Y
        else:
            raise ValueError('Unknown matrix label. Only X and Y are allowed.')


    def get_column_X(self, column):
        """
        Get a column from the ``X`` matrix as a simple 1-dimensional Numpy
        array. It is recommended to call :py:meth`finalize` first, because
        finalizing will convert ``X`` to a CSC matrix, which is optimized for
        column slicing and retrieval.

        :param int column: 0-based integer index of the column to retrieve from ``X``.
        :return: The requested column of ``X`` as a 1-dimensional Numpy array.
        :rtype: ``numpy.array`` of size ``(1, row_count)``.
        """
        return self.X.getcol(column).transpose().toarray().ravel()


    def get_column_Y(self, column):
        """
        Get a column from the ``Y`` matrix as a simple 1-dimensional Numpy
        array. It is recommended to call DatasetMatrix.finalize() first,
        because finalizing will convert ``Y`` to a CSC matrix which is
        optimized for column slicing and retrieval.

        :param int column: 0-based integer index of the column to retrieve from ``Y``.
        :return: The requested column of ``Y`` as a 1-dimensional Numpy array.
        :rtype: ``numpy.array`` of size ``(1, row_count)``.
        """
        return self.Y.getcol(column).transpose().toarray().ravel()


    def delete_row(self, r):
        """
        Delete the row at index ``r``. This results in the deletion of row
        ``r`` from the ``X`` matrix *and* the ``Y`` matrix, **in place**. Also
        deletes the corresponding label from ``row_labels``.

        :param int r: 0-based integer index of the row to delete.
        :return: ``None``
        :raises DatasetMatrixFinalizedError: if :py:meth:`finalize` has already
            been called.
        """
        if self.final == True:
            raise DatasetMatrixFinalizedError(self, "Cannot delete any row.")
        self.X = DatasetMatrix.delete_rows_cols(self.X, row_indices=[r]).tocsr()
        self.Y = DatasetMatrix.delete_rows_cols(self.Y, row_indices=[r]).tocsr()
        del self.row_labels[r]


    def keep_rows(self, rows_to_keep):
        """
        Keep only the rows specified by the indices in ``rows_to_keep``,
        deleting all the other rows from both ``X`` and ``Y``, **in place**.
        This affects the ``row_labels`` as well. For creating a new
        :py:class:`DatasetMatrix` instance containing only a specified subset of rows,
        see :py:meth:`select_rows` instead.

        :param list(int) rows_to_keep: A list of 0-based integer indices of the rows
            which must be kept.
        :return: ``None``
        :raises DatasetMatrixFinalizedError: if :py:meth:`finalize` has already
            been called.
        """
        if self.final == True:
            raise DatasetMatrixFinalizedError(self, "Cannot delete any row.")
        if not isinstance(rows_to_keep, list):
            raise TypeError("Argument 'rows_to_keep' must be a non-empty list")
        if len(rows_to_keep) == 0:
            raise ValueError("Argument 'rows_to_keep' must be a non-empty list")

        all_rows = range(self.X.get_shape()[0])
        rows_to_delete = list(set(all_rows) - set(rows_to_keep))
        self.X = DatasetMatrix.delete_rows_cols(self.X, row_indices=rows_to_delete).tocsr()
        self.Y = DatasetMatrix.delete_rows_cols(self.Y, row_indices=rows_to_delete).tocsr()

        row_labels_to_keep = [self.row_labels[r] for r in rows_to_keep]
        self.row_labels = row_labels_to_keep


    def select_rows(self, rows_to_keep, new_label=""):
        """
        Create a new :py:class:`DatasetMatrix` instance, which only contains the requested
        rows of both ``X`` and ``Y``. Affects ``row_labels`` as well. Does not
        raise ``DatasetMatrixFinalizedError``, because it doesn't try to modify
        the original matrices.

        :param list(int) rows_to_keep: A list of 0-based integer indices of the rows
            which must be kept in the new instance.
        :param str new_label: Optional label for the new instance. If ``""``,
            then ``self.label`` is used.
        :return: A new :py:class:`DatasetMatrix` instance, with ``X`` and ``Y``
            containing only the requested rows.
        :rtype: :py:class:`DatasetMatrix`
        """
        if not isinstance(rows_to_keep, list):
            raise TypeError("Argument 'rows_to_keep' must be a non-empty list")
        if len(rows_to_keep) == 0:
            raise ValueError("Argument 'rows_to_keep' must be a non-empty list")

        rows_to_keep = sorted(rows_to_keep)
        if new_label == "":
            new_label = self.label

        new_dataset_matrix = DatasetMatrix(new_label)

        new_dataset_matrix.X = self.X[rows_to_keep,]
        new_dataset_matrix.Y = self.Y[rows_to_keep,]
        new_dataset_matrix.row_labels = [self.row_labels[i] for i in rows_to_keep]
        new_dataset_matrix.column_labels_X = self.column_labels_X.copy()
        new_dataset_matrix.column_labels_Y = self.column_labels_Y.copy()

        return new_dataset_matrix


    def select_columns_X(self, columns_to_keep, new_label=""):
        """
        Create a new :py:class:`DatasetMatrix` instance, which only contains the requested
        columns in ``X``. Affects ``column_labels_X`` as well. The ``Y`` matrix
        will be copied over to the new instance, as will ``column_labels_Y``. Does not
        raise ``DatasetMatrixFinalizedError``, because it doesn't try to modify
        the original matrices.

        :param list(int) columns_to_keep: A list of 0-based integer indices of
            the columns of ``X`` which must be kept in the new instance.
        :param str new_label: Optional label for the new instance. If ``""``,
            then ``self.label`` is used.
        :return: A new :py:class:`DatasetMatrix` instance, with ``X``
            containing only the requested columns, and a copy of the original
            ``Y``.
        :rtype: :py:class:`DatasetMatrix`
        """

        if not isinstance(columns_to_keep, list):
            raise TypeError("Argument 'columns_to_keep' must be a non-empty list")
        if len(columns_to_keep) == 0:
            raise ValueError("Argument 'columns_to_keep' must be a non-empty list")

        columns_to_keep = sorted(columns_to_keep)
        if new_label == "":
            new_label = self.label

        new_dataset_matrix = DatasetMatrix(new_label)

        new_dataset_matrix.X = self.X[:,columns_to_keep]
        new_dataset_matrix.Y = self.Y.copy()
        new_dataset_matrix.row_labels = self.row_labels.copy()
        new_dataset_matrix.column_labels_X = [self.column_labels_X[i] for i in columns_to_keep]
        new_dataset_matrix.column_labels_Y = self.column_labels_Y.copy()

        return new_dataset_matrix


    def delete_columns_X(self, columns_to_delete):
        """
        Delete multiple columns **in place** from the matrix ``X``. This
        affects ``self.column_labels_X`` too. To delete individual columns from
        ``X``, see :py:meth:`delete_column_X`.

        :param list(int) columns_to_delete: A list of 0-based integer indices
            of the columns to delete from ``X``.
        :return: ``None``
        :raises DatasetMatrixFinalizedError: if :py:meth:`finalize` has already
            been called.
        """
        if self.final == True:
            raise DatasetMatrixFinalizedError(self, "Cannot delete any X column.")
        columns_to_delete = sorted(columns_to_delete)
        self.X = DatasetMatrix.delete_rows_cols(self.X, col_indices=columns_to_delete).tocsr()
        self.column_labels_X = [self.column_labels_X[c] for c in range(len(self.column_labels_X)) if c not in columns_to_delete]


    def delete_columns_Y(self, columns_to_delete):
        """
        Delete multiple columns **in place** from the matrix ``Y``. This
        affects ``self.column_labels_Y`` too. To delete individual columns from
        ``Y``, see :py:meth:`delete_column_Y`.

        :param list(int) columns_to_delete: A list of 0-based integer indices
            of the columns to delete from ``Y``.
        :return: ``None``
        :raises DatasetMatrixFinalizedError: if :py:meth:`finalize` has already
            been called.
        """
        if self.final == True:
            raise DatasetMatrixFinalizedError(self, "Cannot delete any Y column.")
        columns_to_delete = sorted(columns_to_delete)
        self.Y = DatasetMatrix.delete_rows_cols(self.Y, col_indices=columns_to_delete).tocsr()
        self.column_labels_Y = [self.column_labels_Y[c] for c in range(len(self.column_labels_Y)) if c not in columns_to_delete]


    def delete_column_X(self, c):
        """
        Delete a single column **in place** from the matrix ``X``. This
        affects ``self.column_labels_X`` too. To delete multiple columns from
        ``X``, see :py:meth:`delete_column_X`.

        :param int c: The 0-based integer index of the column to delete from
            ``X``.
        :return: ``None``
        :raises DatasetMatrixFinalizedError: if :py:meth:`finalize` has already
            been called.
        """
        if self.final == True:
            raise DatasetMatrixFinalizedError(self, "Cannot delete any X column.")
        self.X = DatasetMatrix.delete_rows_cols(self.X, col_indices=[c]).tocsr()
        del self.column_labels_X[c]


    def delete_column_Y(self, c):
        """
        Delete a single column **in place** from the matrix ``Y``. This
        affects ``self.column_labels_Y`` too. To delete multiple columns from
        ``Y``, see :py:meth:`delete_column_Y`.

        :param int c: The 0-based integer index of the column to delete from
            ``Y``.
        :return: ``None``
        :raises DatasetMatrixFinalizedError: if :py:meth:`finalize` has already
            been called.
        """
        if self.final == True:
            raise DatasetMatrixFinalizedError(self, "Cannot delete any Y column.")
        self.Y = DatasetMatrix.delete_rows_cols(self.Y, col_indices=[c]).tocsr()
        del self.column_labels_Y[c]


    def save(self, path):
        """
        Save ``X``, ``Y``, ``self.row_labels``, ``self.column_labels_X`` and
        ``self.column_labels_Y`` as files in the subfolder
        ``[path]/[self.label]``. To load these back into a
        :py:class:`DatasetMatrix` instance at a later time, use :py:meth:`load`.

        If the folder ``[path]/[self.label]`` does not exist, it will be
        created.

        :param str path: The Path object representing the root folder in which
            to create the subfolder named ``[self.label]`` in which to save.
        :return: ``None``
        """
        if self.final == False:
            raise DatasetMatrixNotFinalizedError(self, "Cannot save.")

        matrix_path = path / self.label
        util.ensure_folder(matrix_path)

        util.save_matrix(matrix_path, "X", self.X)
        util.save_matrix(matrix_path, "Y", self.Y)

        row_labels_file = matrix_path / 'row_labels.txt'
        row_labels_file.write_text('\n'.join(self.row_labels))

        column_labels_X_file = matrix_path / 'column_labels_X.txt'
        column_labels_X_file.write_text('\n'.join(self.column_labels_X))

        column_labels_Y_file = matrix_path / 'column_labels_Y.txt'
        column_labels_Y_file.write_text('\n'.join(self.column_labels_Y))


    def load(self, path):
        """
        Load ``X``, ``Y``, ``self.row_labels``, ``self.column_labels_X`` and
        ``self.column_labels_Y`` from files in the subfolder
        ``[path]/[self.label]``. To save them, use :py:meth:`save`.

        The folder ``[path]/[self.label]`` must exist.

        :param str path: The Path object representing the root folder in which
            to find the subfolder ``[self.label]`` from which to load.
        :return: ``None``
        """
        matrix_path = path / self.label

        self.X = util.load_matrix(matrix_path, "X")
        self.Y = util.load_matrix(matrix_path, "Y")

        with (matrix_path / 'row_labels.txt').open(mode='rt') as f:
            self.row_labels = list(map(str.strip, list(f)))

        with (matrix_path / 'column_labels_X.txt').open(mode='rt') as f:
            self.column_labels_X = list(map(str.strip, list(f)))

        with (matrix_path / 'column_labels_Y.txt').open(mode='rt') as f:
            self.column_labels_Y = list(map(str.strip, list(f)))

        self.final = True


    def finalize(self):
        """
        Make final adjustments to the ``X`` and ``Y`` matrices. Calls
        ``.eliminate_zeros()``, ``.check_format()`` and ``.tocsc()`` on both
        matrices, then set the ``self.final`` flag to ``True``.

        :return: ``None``
        """
        if self.final == True:
            return

        self.X.eliminate_zeros()
        self.Y.eliminate_zeros()

        self.X.check_format()
        self.Y.check_format()

        self.X = self.X.tocsc()
        self.Y = self.Y.tocsc()

        self.final = True


    def unfinalize(self):
        """
        Reset the ``self.final`` flag and converts ``X`` and ``Y`` back to CSR
        format. This method should not really be used unless for development or
        testing purposes.

        :return: ``None``
        """
        self.X = self.X.tocsr()
        self.Y = self.Y.tocsr()

        self.final = False


    def __eq__(self, other):
        """
        Enable equality testing with the ``==`` operator.

        This equality test includes ``X``, ``Y``, ``row_labels``,
        ``column_labels_X`` and ``column_labels_Y``. All of these properties
        must be equal between the two given instances for the equality test to
        pass.
        """
        if self.row_labels != other.row_labels:
            return False
        if self.column_labels_X != other.column_labels_X:
            return False
        if self.column_labels_Y != other.column_labels_Y:
            return False
        if not DatasetMatrix.sparse_equal(self.X, other.X):
            return False
        if not DatasetMatrix.sparse_equal(self.Y, other.Y):
            return False
        return True


    def diff(self, other):
        """
        Generate a textual description of how this :py:class:`DatasetMatrix`
        differs from the ``other``. For development purposes only.
        """
        output = ""
        if self.row_labels != other.row_labels:
            output += "row_labels "
        if self.column_labels_X != other.column_labels_X:
            output += "column_labels_X "
        if self.column_labels_Y != other.column_labels_Y:
            output += "column_labels_Y "
        if not DatasetMatrix.sparse_equal(self.X, other.X):
            output += "X "
        if not DatasetMatrix.sparse_equal(self.Y, other.Y):
            output += "Y"
        return output.strip()



    # Utility static methods.
    ########################

    def sparse_equal(m1, m2):
        """
        Test for the equality of two sparse matrices, by comparing their shape and their content.

        :param scipy.sparse m1: A sparse matrix.
        :param scipy.sparse m2: Another sparse matrix.
        :return: ``True`` if the shape and contents of ``m1`` and ``m2`` are
            identical, False otherwise.
        :rtype: `bool`
        """
        if m1.get_shape() != m2.get_shape():
            return False
        if (m1 != m2).nnz != 0:
            return False
        return True


    # Taken from https://stackoverflow.com/a/45486349/583574
    def delete_rows_cols(mat, row_indices=[], col_indices=[]):
        """
        Remove multiple rows and columns simultaneously from the CSR sparse matrix ``mat``.
        WARNING: Indices of altered axes are reset in the returned matrix.

        See `this StackOverflow answer <https://stackoverflow.com/a/45486349/583574>`_.

        :param scipy.sparse.csr_matrix mat: The Scipy CSR matrix to delete rows
            and columns from.
        :param list(int) row_indices: A list of 0-based integer indices of the
            rows to delete.
        :param list(int) col_indices: A list of 0-based integer indices of the
            columns to delete.
        :return: A new Scipy CSR matrix instance that does not contain the
            specified rows and columns.
        :rtype: scipy.sparse.csr_matrix
        """
        if not isinstance(mat, scipy.sparse.csr_matrix):
            raise ValueError("works only for CSR format -- use .tocsr() first")

        rows = []
        cols = []
        if row_indices:
            rows = list(row_indices)
        if col_indices:
            cols = list(col_indices)

        if len(rows) > 0 and len(cols) > 0:
            row_mask = numpy.ones(mat.shape[0], dtype=bool)
            row_mask[rows] = False
            col_mask = numpy.ones(mat.shape[1], dtype=bool)
            col_mask[cols] = False
            return mat[row_mask][:,col_mask]
        elif len(rows) > 0:
            mask = numpy.ones(mat.shape[0], dtype=bool)
            mask[rows] = False
            return mat[mask]
        elif len(cols) > 0:
            mask = numpy.ones(mat.shape[1], dtype=bool)
            mask[cols] = False
            return mat[:,mask]
        else:
            return mat


